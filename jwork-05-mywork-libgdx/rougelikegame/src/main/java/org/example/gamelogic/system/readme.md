
### 碰撞系统的实现：
实体之间的唯一交互方式：碰撞
#### 实体的碰撞体积
默认实体都是圆型，只需读取位置组件中的位置和碰撞组件中实体的半径即可
#### 碰撞检测
1. 采用两两检测的方式
2. 缺少优化算法，即排除某些不必要检测的pair
3. 利用libgdx中的Circle.overLap方法
进行每一对之间的碰撞检测
#### 碰撞处理
对于检测出发生碰撞的实体对该如何处理

例子：在实体A的碰撞检测中发现了A与B,C,D,E相碰撞
##### 方案一：
1. *CollisionDetectionSystem*将B,C,D,E添加到A的碰撞列表中，将A添加到B,C,D,E的碰撞列表中
备注：在每一帧开始前，应该把所有有[碰撞组件]的实体的碰撞列表给清空
//子弹与僵尸，僵尸与玩家的碰撞
2. *DamageSystem*对于含有[生命组件]和[碰撞组件]的实体(例如A)，检测其碰撞列表，
如果发现其中含有带[攻击组件]的成员B，则减少A等同于B.[攻击组件].damage的血量
//玩家与墙，僵尸与墙，玩家与僵尸的碰撞
3. *CollisionRespondSystem*对于含有[可移动组件]和[碰撞组件]的实体(例如A)，检测其碰撞列表，
如果不为空，则使其速度变为0(后续可以加入如[质量组件]来达到冲量改变速度的行为)
注意：SystemC必须放置到所有改变[可移动组件]的最后一个和*MovementSystem*之前，
否则会导致碰撞体积不生效，同时在引入冲量之前每次碰撞都会导致实体“不可动(v=0)”，因此
冲量的引入必不可少
//子弹与墙，子弹与僵尸的碰撞
4. *SystemD*对于含有[碰撞组件]和[子弹组件]的实体，检测其碰撞列表，如果碰撞列表不为空，
将其[销毁组件]添加到该实体的组件列表中

